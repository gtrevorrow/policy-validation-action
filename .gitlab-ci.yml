# This file is aligned with the testing strategy from test.yml and bitbucket-pipelines.yml
image: node:18

stages:
  - test

test:
  stage: test
  script:
    # Install dependencies
    - apt-get update && apt-get install -y jq
    - npm ci
    - npm run build
    
    # Run Jest unit tests first and generate a JUnit report
    - |
      echo "Running Jest Unit Tests..."
      npm test -- --reporters=default --reporters=jest-junit
      echo "Jest tests completed."

    # Create a comprehensive set of test policies, mirroring the other CI workflows
    - |
      echo "Creating test policy files..."
      mkdir -p test/policies
      # Valid policy file
      cat > test/policies/valid.tf << 'EOL'
      resource "oci_identity_policy" "valid_policy" {
        statements = [
          "Allow group Administrators to manage all-resources in tenancy",
          "Allow group Developers to use instances in compartment dev"
        ]
      }
      EOL
      
      # Invalid policy file
      cat > test/policies/invalid.tf << 'EOL'
      resource "oci_identity_policy" "invalid_policy" {
        statements = [
          "Invalid policy statement that should fail",
          "Allow BadSyntax manage"
        ]
      }
      EOL
      
      # Valid policy file with HCL variables
      cat > test/policies/valid_vars.tf << 'EOL'
      resource "oci_identity_policy" "valid_policy_vars" {
        statements = [
          "Allow group ${var.admin_group} to manage all-resources in tenancy",
          "Allow group Developers to use ${var.resource_type} in compartment ${var.dev_compartment}"
        ]
      }
      EOL
      
      # Valid policy file with HCL variables in conditions
      cat > test/policies/valid_conditions.tf << 'EOL'
      resource "oci_identity_policy" "valid_policy_conditions" {
        statements = [
          "Allow group Developers to use instances in compartment dev where request.user.id = '${var.user_id}'"
        ]
      }
      EOL
      
      # Test file with all expression types
      cat > test/policies/all_expressions.tf << 'EOL'
      resource "oci_identity_policy" "all_expressions" {
        statements = [
          "define tenancy Acceptor as ocid1.tenancy.oc1..aaaaaaaanneylhk3ibv2dmorxqgklcloydwnror5b3fs4ag7dlrbsiwkjdea",
          "endorse group Administrators to manage drg-attachment in tenancy VCN",
          "Admit group Administrators of tenancy Requestor to manage remote-peering-to in tenancy",
          "Allow group ${var.admin_group} to manage all-resources in tenancy"
        ]
      }
      EOL
      
      # Test file with CIS benchmark violations (syntactically valid)
      cat > test/policies/cis_violations.tf << 'EOL'
      resource "oci_identity_policy" "cis_violations" {
        statements = [
          "Allow group NonAdmins to manage all-resources in tenancy",
          "Allow group SecurityAdmins to manage vault-family in tenancy"
        ]
      }
      EOL
      echo "Test policy files created."

    # Run integration tests by executing the compiled action script
    - |
      echo "Running Integration Tests..."
      
      # Verification function adapted from the Bitbucket pipeline
      verify_output() {
        local test_name="$1"
        local expected_validity="$2"
        local failure_mode="${3:-strict}"
        local command_to_run="$4"
        
        echo "--- Verifying: $test_name (Expected: $expected_validity, Mode: $failure_mode) ---"
        
        local output
        local exit_code=0
        output=$(eval "$command_to_run" 2>&1) || exit_code=$?
        
        echo "Command exit code: $exit_code"
        echo "Raw output:"
        echo "$output"
        
        if [ -z "$output" ]; then
          echo "ERROR: Output was empty for $test_name."
          return 1
        fi

        # Isolate the JSON part of the output
        local json_output
        json_output=$(echo "$output" | sed -n '/^{/,$p')

        if [ -z "$json_output" ]; then
            echo "ERROR: No JSON found in the output for $test_name."
            return 1
        fi
        
        local jq_filter
        if [[ "$failure_mode" == "warnings" ]]; then
          jq_filter='if ([ .[] | .results[] | .reports[] | .passed ] | index(false)) or ([ .[] | .results[] | .reports[] | .status ] | map(. != "pass") | any) then "false" else "true" end'
        else
          jq_filter='if ([ .[] | .results[] | .reports[] | .passed ] | index(false)) then "false" else "true" end'
        fi
        
        local actual_validity
        # The output is double-encoded JSON: {"results": "[...]"}.
        # We need to parse the outer object, get the .results string, and parse it again with fromjson.
        actual_validity=$(echo "$json_output" | jq -r ".results | fromjson | if type==\"array\" and length > 0 then $jq_filter else \"null\" end" 2>/dev/null)
        
        echo "Extracted validity: $actual_validity"
        
        if [[ "$actual_validity" != "$expected_validity" ]]; then
          echo "ERROR: For '$test_name', expected validity '$expected_validity' but got '$actual_validity'."
          return 1
        fi
        
        echo "âœ“ OK: $test_name"
        return 0
      }
      
      errors=0
      
      # Define test cases, setting VALIDATE_GLOBAL=true to ensure comprehensive validation
      verify_output "test-valid" "true" "strict" "VALIDATE_GLOBAL=true node dist/index.js validate test/policies/valid.tf" || errors=$((errors + 1))
      verify_output "test-invalid" "false" "strict" "VALIDATE_GLOBAL=true node dist/index.js validate test/policies/invalid.tf" || errors=$((errors + 1))
      verify_output "test-vars" "false" "warnings" "VALIDATE_GLOBAL=true node dist/index.js validate test/policies/valid_vars.tf" || errors=$((errors + 1))
      verify_output "test-conditions" "true" "strict" "VALIDATE_GLOBAL=true node dist/index.js validate test/policies/valid_conditions.tf" || errors=$((errors + 1))
      verify_output "test-expressions" "true" "strict" "VALIDATE_GLOBAL=true node dist/index.js validate test/policies/all_expressions.tf" || errors=$((errors + 1))
      verify_output "test-cis-violations" "false" "strict" "VALIDATE_GLOBAL=true node dist/index.js validate test/policies/cis_violations.tf" || errors=$((errors + 1))
      verify_output "test-custom-pattern" "true" "strict" "VALIDATE_GLOBAL=true node dist/index.js validate test/policies/valid.tf --extractor regex --pattern 'statements\s*=\s*\[(.*?)\]'" || errors=$((errors + 1))
      verify_output "test-custom-pattern-env-var" "true" "strict" "POLICY_STATEMENTS_PATTERN=\"statements\\\\s*=\\\\s*\\\\[(.*?)\\\\]\" VALIDATE_GLOBAL=true node dist/index.js validate test/policies/valid.tf --extractor regex" || errors=$((errors + 1))
      
      if [ $errors -gt 0 ]; then
        echo "ERROR: $errors integration verification(s) failed."
        exit 1
      else
        echo "All integration tests verified successfully."
      fi
  artifacts:
    when: always
    reports:
      junit: test-results/junit.xml
