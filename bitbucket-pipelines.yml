image: node:18

definitions:
  steps:
    - step: &build
        name: Build
        clone:
          depth: full
        caches:
          - node
        script:
          - npm ci
          - npm run build
        artifacts:
          - dist/**

    - step: &test
        name: Test
        caches:
          - node
        script:
          - apt-get update && apt-get install -y jq
          - npm ci
          - npm run build
          
          # Run Jest unit tests first
          - |
            echo "Running Jest Unit Tests..."
            npm test -- --reporters=default --reporters=jest-junit
            echo "Jest tests completed."
          
          # Create a comprehensive set of test policies, mirroring the GitHub Actions workflow
          - |
            echo "Creating test policy files..."
            mkdir -p test/policies
            # Valid policy file
            cat > test/policies/valid.tf << 'EOL'
            resource "oci_identity_policy" "valid_policy" {
              statements = [
                "Allow group Administrators to manage all-resources in tenancy",
                "Allow group Developers to use instances in compartment dev"
              ]
            }
            EOL
            
            # Invalid policy file
            cat > test/policies/invalid.tf << 'EOL'
            resource "oci_identity_policy" "invalid_policy" {
              statements = [
                "Invalid policy statement that should fail",
                "Allow BadSyntax manage"
              ]
            }
            EOL
            
            # Valid policy file with HCL variables
            cat > test/policies/valid_vars.tf << 'EOL'
            resource "oci_identity_policy" "valid_policy_vars" {
              statements = [
                "Allow group ${var.admin_group} to manage all-resources in tenancy",
                "Allow group Developers to use ${var.resource_type} in compartment ${var.dev_compartment}"
              ]
            }
            EOL
            
            # Valid policy file with HCL variables in conditions
            cat > test/policies/valid_conditions.tf << 'EOL'
            resource "oci_identity_policy" "valid_policy_conditions" {
              statements = [
                "Allow group Developers to use instances in compartment dev where request.user.id = '${var.user_id}'"
              ]
            }
            EOL
            
            # Test file with all expression types
            cat > test/policies/all_expressions.tf << 'EOL'
            resource "oci_identity_policy" "all_expressions" {
              statements = [
                "define tenancy Acceptor as ocid1.tenancy.oc1..aaaaaaaanneylhk3ibv2dmorxqgklcloydwnror5b3fs4ag7dlrbsiwkjdea",
                "endorse group Administrators to manage drg-attachment in tenancy VCN",
                "Admit group Administrators of tenancy Requestor to manage remote-peering-to in tenancy",
                "Allow group ${var.admin_group} to manage all-resources in tenancy"
              ]
            }
            EOL
            
            # Test file with CIS benchmark violations (syntactically valid)
            cat > test/policies/cis_violations.tf << 'EOL'
            resource "oci_identity_policy" "cis_violations" {
              statements = [
                "Allow group NonAdmins to manage all-resources in tenancy",
                "Allow group SecurityAdmins to manage vault-family in tenancy"
              ]
            }
            EOL

            # Test file for agentic validator with variable-based violations
            cat > test/policies/agentic_test.tf << 'EOL'
            resource "oci_identity_policy" "agentic_test" {
              statements = [
                "Allow group ${var.dangerous_group} to manage all-resources in tenancy"
              ]
            }
            EOL
            echo "Test policy files created."

          # Run integration tests by executing the compiled action script
          - |
            echo "Running Integration Tests..."
            
            # Verification function similar to the one in the GitHub Actions workflow
            verify_output() {
              local test_name="$1"
              local expected_validity="$2"
              local failure_mode="${3:-strict}"
              local command_to_run="$4"
              
              echo "--- Verifying: $test_name (Expected: $expected_validity, Mode: $failure_mode) ---"
              
              local output
              local exit_code=0
              output=$(eval "$command_to_run" 2>&1) || exit_code=$?
              
              echo "Command exit code: $exit_code"
              echo "Raw output:"
              echo "$output"
              
              if [ -z "$output" ]; then
                echo "::error:: Output was empty for $test_name."
                return 1
              fi

              # Isolate the JSON part of the output, ignoring potential ERROR lines from stderr
              local json_output
              json_output=$(echo "$output" | sed -n '/^{/,$p')

              if [ -z "$json_output" ]; then
                  echo "::error:: No JSON found in the output for $test_name."
                  return 1
              fi
              
              local jq_filter
              if [[ "$failure_mode" == "warnings" ]]; then
                jq_filter='if ([ .[] | .results[] | .reports[] | .passed ] | index(false)) or ([ .[] | .results[] | .reports[] | .status ] | map(. != "pass") | any) then "false" else "true" end'
              else
                jq_filter='if ([ .[] | .results[] | .reports[] | .passed ] | index(false)) then "false" else "true" end'
              fi
              
              local actual_validity
              # The output is double-encoded JSON: {"results": "[...]"}.
              # We need to parse the outer object, get the .results string, and parse it again with fromjson.
              actual_validity=$(echo "$json_output" | jq -r ".results | fromjson | if type==\"array\" and length > 0 then $jq_filter else \"null\" end" 2>/dev/null)
              
              echo "Extracted validity: $actual_validity"
              
              if [[ "$actual_validity" != "$expected_validity" ]]; then
                echo "::error:: For '$test_name', expected validity '$expected_validity' but got '$actual_validity'."
                return 1
              fi
              
              echo "âœ“ OK: $test_name"
              return 0
            }
            
            errors=0
            
            # Define test cases, setting VALIDATE_GLOBAL=true to ensure comprehensive validation
            verify_output "test-valid" "true" "strict" "VALIDATE_GLOBAL=true node dist/index.js validate test/policies/valid.tf" || errors=$((errors + 1))
            verify_output "test-invalid" "false" "strict" "VALIDATE_GLOBAL=true node dist/index.js validate test/policies/invalid.tf" || errors=$((errors + 1))
            verify_output "test-vars" "false" "warnings" "VALIDATE_GLOBAL=true node dist/index.js validate test/policies/valid_vars.tf" || errors=$((errors + 1))
            verify_output "test-conditions" "true" "strict" "VALIDATE_GLOBAL=true node dist/index.js validate test/policies/valid_conditions.tf" || errors=$((errors + 1))
            verify_output "test-expressions" "true" "strict" "VALIDATE_GLOBAL=true node dist/index.js validate test/policies/all_expressions.tf" || errors=$((errors + 1))
            verify_output "test-cis-violations" "false" "strict" "VALIDATE_GLOBAL=true node dist/index.js validate test/policies/cis_violations.tf" || errors=$((errors + 1))
            verify_output "test-custom-pattern" "true" "strict" "VALIDATE_GLOBAL=true node dist/index.js validate test/policies/valid.tf --extractor regex --pattern 'statements\s*=\s*\[(.*?)\]'" || errors=$((errors + 1))
            verify_output "test-custom-pattern-env-var" "true" "strict" "POLICY_STATEMENTS_PATTERN=\"statements\\\\s*=\\\\s*\\\\[(.*?)\\\\]\" VALIDATE_GLOBAL=true node dist/index.js validate test/policies/valid.tf --extractor regex" || errors=$((errors + 1))
            
            # Agentic and Real-World tests (API key should be a repository variable)
            verify_output "test-agentic" "false" "warnings" "node dist/index.js validate test/policies/agentic_test.tf --agentic-validation-enabled=true --agentic-validation-provider=google --agentic-validation-model='Gemini 2.5 pro' --agentic-validation-api-key='$GOOGLE_API_KEY'" || errors=$((errors + 1))
            verify_output "test-real-world" "false" "strict" "node dist/index.js validate test/policies --validators-global=true --agentic-validation-enabled=true --agentic-validation-provider=google --agentic-validation-model='Gemini 2.5 pro' --agentic-validation-api-key='$GOOGLE_API_KEY' --extractor=regex --pattern=\"statements\\\\s*=\\\\s*\\\\[\\\\s*((?:[^[\\]]*?(?:\\\"(?:[^\\\"\\\\]|\\\\\\\\.)*\\\"|'(?:[^'\\\\]|\\\\\\\\.)*'|\\\\\\\\$\\\\{(?:[^{}]|\\\\{[^{}]*\\\\})*\\\\})?)*)\\\\s*\\\\]\"" || errors=$((errors + 1))

            if [ $errors -gt 0 ]; then
              echo "::error::$errors integration verification(s) failed."
              exit 1
            else
              echo "All integration tests verified successfully."
            fi
        
        artifacts:
          reports:
            junit: test-results/junit.xml

pipelines:
  default:
    - step: *build
    - parallel:
      - step: *test
  
  branches:
    main:
      - step: *build
      - step: *test
      - step:
          name: Publish to NPM
          image: node:18
          deployment: production
          script:
            - pipe: atlassian/npm-publish:1.2.0
              variables:
                NPM_TOKEN: $NPM_TOKEN
          trigger: manual

  pull-requests:
    '**':
      - step: *build
      - parallel:
        - step: *test

custom:
  release:
    - step: *build
    - step: *test
    - step:
        name: Publish to NPM
        image: node:18
        script:
          - pipe: atlassian/npm-publish:1.2.0
            variables:
              NPM_TOKEN: $NPM_TOKEN
caches:
  node: ~/.npm
