name: Test Policy Validation Action
on: [push, pull_request]

jobs:
  test-action:
    runs-on: ubuntu-latest
    name: Test Policy Validation
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Build action
        run: npm run build
        
      - name: Create test policies
        run: |
          mkdir -p test/policies
          # Valid policy file
          cat > test/policies/valid.tf << 'EOL'
          resource "oci_identity_policy" "valid_policy" {
            statements = [
              "Allow group Administrators to manage all-resources in tenancy",
              "Allow group Developers to use instances in compartment dev"
            ]
          }
          EOL
          
          # Invalid policy file
          cat > test/policies/invalid.tf << 'EOL'
          resource "oci_identity_policy" "invalid_policy" {
            statements = [
              "Invalid policy statement that should fail",
              "Allow BadSyntax manage"
            ]
          }
          EOL
          
          # Valid policy file with HCL variables
          cat > test/policies/valid_vars.tf << 'EOL'
          resource "oci_identity_policy" "valid_policy_vars" {
            statements = [
              "Allow group ${var.admin_group} to manage all-resources in tenancy",
              "Allow group Developers to use ${var.resource_type} in compartment ${var.dev_compartment}",
              "Allow any-user to use ${var.public_resource} in compartment ${var.public_compartment} where request.user.id = '${var.allowed_user}'"
            ]
          }
          EOL
          
          # Valid policy file with HCL variables in conditions
          cat > test/policies/valid_conditions.tf << 'EOL'
          resource "oci_identity_policy" "valid_policy_conditions" {
            statements = [
              "Allow group Developers to use instances in compartment dev where request.user.id = '${var.user_id}'",
              "Allow group Admins to manage volumes in compartment prod where request.networkSource.name = ${var.network_source}",
              "Allow any-user to use instances in compartment public where request.time BETWEEN ${var.start_time} AND ${var.end_time}"
            ]
          }
          EOL
          
          # Test file with all expression types
          cat > test/policies/all_expressions.tf << 'EOL'
          resource "oci_identity_policy" "all_expressions" {
            statements = [
              "define tenancy Acceptor as ocid1.tenancy.oc1..aaaaaaaanneylhk3ibv2dmorxqgklcloydwnror5b3fs4ag7dlrbsiwkjdea",
              "endorse group Administrators to manage drg-attachment in tenancy VCN",
              "Admit group Administrators of tenancy Requestor to manage remote-peering-to in tenancy",
              "Allow group ${var.admin_group} to manage all-resources in tenancy"
            ]
          }
          EOL
          
          # Verify files were created
          ls -la test/policies/
          cat test/policies/valid.tf
          cat test/policies/invalid.tf
          
      - name: Test valid policy
        id: test-valid
        continue-on-error: true
        uses: ./
        with:
          path: './test/policies/valid.tf'
        env:
          GITHUB_ACTIONS: true
          
      - name: Save test-valid output
        if: always() # Run even if the previous step failed
        run: |
          echo "Debug output for test-valid:"
          echo '${{ steps.test-valid.outputs.results }}'
          echo '${{ steps.test-valid.outputs.results }}' > /tmp/test-valid-output.json

      - name: Test invalid policy
        id: test-invalid
        continue-on-error: true
        uses: ./
        with:
          path: './test/policies/invalid.tf'
        env:
          GITHUB_ACTIONS: true
          
      - name: Save test-invalid output
        if: always()
        run: |
          echo "Debug output for test-invalid:"
          echo '${{ steps.test-invalid.outputs.results }}'
          echo '${{ steps.test-invalid.outputs.results }}' > /tmp/test-invalid-output.json

      - name: Test policy with variables
        id: test-vars
        continue-on-error: true
        uses: ./
        with:
          path: './test/policies/valid_vars.tf'
        env:
          GITHUB_ACTIONS: true
          
      - name: Save test-vars output
        if: always()
        run: |
          echo "Debug output for test-vars:"
          echo '${{ steps.test-vars.outputs.results }}'
          echo '${{ steps.test-vars.outputs.results }}' > /tmp/test-vars-output.json

      - name: Test conditions with variables
        id: test-conditions
        continue-on-error: true
        uses: ./
        with:
          path: './test/policies/valid_conditions.tf'
        env:
          GITHUB_ACTIONS: true
          
      - name: Save test-conditions output
        if: always()
        run: |
          echo "Debug output for test-conditions:"
          echo '${{ steps.test-conditions.outputs.results }}'
          echo '${{ steps.test-conditions.outputs.results }}' > /tmp/test-conditions-output.json

      - name: Test all expressions
        id: test-expressions
        continue-on-error: true
        uses: ./
        with:
          path: './test/policies/all_expressions.tf'
        env:
          GITHUB_ACTIONS: true
          
      - name: Save test-expressions output
        if: always()
        run: |
          echo "Debug output for test-expressions:"
          echo '${{ steps.test-expressions.outputs.results }}'
          echo '${{ steps.test-expressions.outputs.results }}' > /tmp/test-expressions-output.json

      - name: Test custom extractor pattern
        id: test-custom-pattern
        continue-on-error: true
        uses: ./
        with:
          path: './test/policies/valid.tf'
          extractor: 'regex'
          pattern: 'statements\s*=\s*\[(.*?)\]' # Changed extractorPattern to pattern
        env:
          GITHUB_ACTIONS: true

      - name: Save test-custom-pattern output
        if: always()
        run: |
          echo "Debug output for test-custom-pattern:"
          echo '${{ steps.test-custom-pattern.outputs.results }}'
          echo '${{ steps.test-custom-pattern.outputs.results }}' > /tmp/test-custom-pattern-output.json

      - name: Test custom extractor pattern using env variable
        id: test-custom-pattern-env-var
        continue-on-error: true
        env:
          # NOTE: The 'pattern' input takes precedence over this env var if both are set.
          # This step tests if the action correctly falls back to the env var when 'pattern' input is NOT provided.
          POLICY_STATEMENTS_PATTERN: "statements\\s*=\\s*\\[\\s*((?:[^[\\]]*?(?:\"(?:[^\"\\\\]|\\\\.)*\"|'(?:[^'\\\\]|\\.)*'|\\$\\{(?:[^{}]|\\{[^{}]*\\})*\\})?)*)\\s*\\]"
          GITHUB_ACTIONS: true
        uses: ./
        with:
          path: './test/policies/valid.tf'
          extractor: 'regex'
          # No 'pattern' input here, relying on env var

      - name: Save test-custom-pattern-env-var output
        if: always()
        run: |
          echo "Debug output for test-custom-pattern-env-var:"
          echo '${{ steps.test-custom-pattern-env-var.outputs.results }}'
          echo '${{ steps.test-custom-pattern-env-var.outputs.results }}' > /tmp/test-custom-pattern-env-var-output.json

      - name: Test action with fixtures
        id: test-fixtures
        continue-on-error: true
        uses: ./
        with:
          path: './src/__tests__/fixtures'
          extractor: 'regex'
          pattern: "statements\\s*=\\s*\\[\\s*((?:[^[\\]]*?(?:\"(?:[^\"\\\\]|\\\\.)*\"|'(?:[^'\\\\]|\\.)*'|\\$\\{(?:[^{}]|\\{[^{}]*\\})*\\})?)*)\\s*\\]" # Changed extractorPattern to pattern
        env:
          GITHUB_ACTIONS: true

      - name: Save test-fixtures output
        if: always()
        run: |
          echo "Debug output for test-fixtures:"
          echo '${{ steps.test-fixtures.outputs.results }}'
          echo '${{ steps.test-fixtures.outputs.results }}' > /tmp/test-fixtures-output.json

      - name: Verify test results
        if: always() # Ensure verification runs even if tests failed
        shell: bash
        # No env vars needed here for outputs
        run: |
          # Function to verify the JSON output and the 'isValid' flag
          verify_output() {
            local step_id="$1"           # Step ID for logging purposes
            local expected_validity="$2" # Expect 'true' or 'false'
            local filename="/tmp/${step_id}-output.json"

            echo "Verifying output from step: $step_id"

            if [ ! -f "$filename" ]; then
              echo "::error::Output file $filename not found for step $step_id."
              return 1
            fi

            # Read the raw output from the file
            local raw_output
            raw_output=$(cat "$filename")

            echo "Raw output value (from file $filename):"
            # Log raw output carefully
            printf '%s\n' "$raw_output" | jq . # Attempt to pretty print if it's JSON

            # Check if the raw_output is empty OR if it's the literal unevaluated expression string
            if [ -z "$raw_output" ] || [[ "$raw_output" == \$\{\{*\}\} ]]; then
              echo "::warning::Output file $filename was empty or contained unevaluated expression for step $step_id."
              echo "::error::No valid output found for step $step_id"
              return 1
            fi

            # Use the raw_output variable which contains the JSON string
            # Use process substitution with printf for safer input to jq
            local actual_validity
            local jq_output
            jq_output=$(jq -r '
              if type == "array" and length > 0 then
                # Check the first element that has an 'isValid' property
                map(select(.isValid != null)) | .[0].isValid // "null"
              elif type == "object" and (.isValid != null) then
                 # Handle case where output might be a single object, not an array
                 .isValid // "null"
              else
                "invalid_json_or_empty"
              end
            ' <(printf '%s' "$raw_output") 2>/dev/null) # Redirect jq errors to /dev/null
            local jq_exit_code=$? # Capture exit code immediately

            # Check jq exit status
            if [ $jq_exit_code -ne 0 ]; then
               echo "::error::jq failed to parse JSON content from $filename for step $step_id."
               printf 'Problematic file content:\n%s\n' "$raw_output"
               actual_validity="invalid_json_or_empty" # Force failure path
            else
               actual_validity="$jq_output" # Assign the valid output
            fi

            echo "Extracted validity: $actual_validity" # Debugging line

            if [[ "$actual_validity" == "invalid_json_or_empty" ]]; then
              echo "::error::Output for $step_id is not a valid JSON array/object, is empty, or lacks 'isValid' in relevant elements."
              printf 'Problematic JSON input:\n%s\n' "$raw_output" # Log the problematic input
              return 1
            elif [[ "$actual_validity" == "null" ]]; then
              echo "::error::Output for $step_id is missing the 'isValid' property in the first relevant element."
              printf 'Problematic JSON input:\n%s\n' "$raw_output" # Log the problematic input
              return 1
            elif [[ "$actual_validity" != "$expected_validity" ]]; then
              echo "::error::Expected validity '$expected_validity' but got '$actual_validity' for step $step_id."
              return 1
            fi

            echo "âœ“ Output for $step_id verified successfully (isValid=$actual_validity)"
            return 0
          }

          # --- Verification ---
          errors=0

          # Call verify_output and check exit status $? separately
          verify_output "test-valid" "true"
          if [ $? -ne 0 ]; then errors=$((errors + 1)); fi

          verify_output "test-invalid" "false"
          if [ $? -ne 0 ]; then errors=$((errors + 1)); fi

          verify_output "test-vars" "true"
          if [ $? -ne 0 ]; then errors=$((errors + 1)); fi

          verify_output "test-conditions" "true"
          if [ $? -ne 0 ]; then errors=$((errors + 1)); fi

          verify_output "test-expressions" "true"
          if [ $? -ne 0 ]; then errors=$((errors + 1)); fi

          verify_output "test-custom-pattern" "true"
          if [ $? -ne 0 ]; then errors=$((errors + 1)); fi

          verify_output "test-custom-pattern-env-var" "true"
          if [ $? -ne 0 ]; then errors=$((errors + 1)); fi

          verify_output "test-fixtures" "false"
          if [ $? -ne 0 ]; then errors=$((errors + 1)); fi

          # --- Final Check ---
          if [ $errors -gt 0 ]; then
            echo "::error::$errors verification(s) failed."
            exit 1
          else
            echo "All action outputs verified successfully."
          fi

      - name: Run Jest tests # Keep Jest tests as a separate check
        run: npm test

      - name: Verify Jest test results # Keep Jest verification
        run: |
          # This step only checks if the previous Jest step succeeded
          if [[ "${{ job.status }}" == "success" ]]; then
            echo "Tests passed successfully"
            exit 0
          else
            echo "Tests failed"
            exit 1


