name: Test Policy Validation Action
on: [push, pull_request]

jobs:
  test-action:
    runs-on: ubuntu-latest
    name: Test Policy Validation
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Build action
        run: npm run build
        
      - name: Create test policies
        run: |
          mkdir -p test/policies
          # Valid policy file
          cat > test/policies/valid.tf << 'EOL'
          resource "oci_identity_policy" "valid_policy" {
            statements = [
              "Allow group Administrators to manage all-resources in tenancy",
              "Allow group Developers to use instances in compartment dev"
            ]
          }
          EOL
          
          # Invalid policy file
          cat > test/policies/invalid.tf << 'EOL'
          resource "oci_identity_policy" "invalid_policy" {
            statements = [
              "Invalid policy statement that should fail",
              "Allow BadSyntax manage"
            ]
          }
          EOL
          
          # Valid policy file with HCL variables
          cat > test/policies/valid_vars.tf << 'EOL'
          resource "oci_identity_policy" "valid_policy_vars" {
            statements = [
              "Allow group ${var.admin_group} to manage all-resources in tenancy",
              "Allow group Developers to use ${var.resource_type} in compartment ${var.dev_compartment}",
              "Allow any-user to use ${var.public_resource} in compartment ${var.public_compartment} where request.user.id = '${var.allowed_user}'"
            ]
          }
          EOL
          
          # Valid policy file with HCL variables in conditions
          cat > test/policies/valid_conditions.tf << 'EOL'
          resource "oci_identity_policy" "valid_policy_conditions" {
            statements = [
              "Allow group Developers to use instances in compartment dev where request.user.id = '${var.user_id}'",
              "Allow group Admins to manage volumes in compartment prod where request.networkSource.name = ${var.network_source}",
              "Allow any-user to use instances in compartment public where request.time BETWEEN ${var.start_time} AND ${var.end_time}"
            ]
          }
          EOL
          
          # Test file with all expression types
          cat > test/policies/all_expressions.tf << 'EOL'
          resource "oci_identity_policy" "all_expressions" {
            statements = [
              "define tenancy Acceptor as ocid1.tenancy.oc1..aaaaaaaanneylhk3ibv2dmorxqgklcloydwnror5b3fs4ag7dlrbsiwkjdea",
              "endorse group Administrators to manage drg-attachment in tenancy VCN",
              "Admit group Administrators of tenancy Requestor to manage remote-peering-to in tenancy",
              "Allow group ${var.admin_group} to manage all-resources in tenancy"
            ]
          }
          EOL
          
          # Verify files were created
          ls -la test/policies/
          cat test/policies/valid.tf
          cat test/policies/invalid.tf
          
      - name: Test valid policy
        id: test-valid
        continue-on-error: true
        uses: ./
        with:
          path: './test/policies/valid.tf'
        env:
          GITHUB_ACTIONS: true
          
      - name: Test invalid policy
        id: test-invalid
        continue-on-error: true
        uses: ./
        with:
          path: './test/policies/invalid.tf'
        env:
          GITHUB_ACTIONS: true
          
      - name: Test policy with variables
        id: test-vars
        continue-on-error: true
        uses: ./
        with:
          path: './test/policies/valid_vars.tf'
        env:
          GITHUB_ACTIONS: true
          
      - name: Test conditions with variables
        id: test-conditions
        continue-on-error: true
        uses: ./
        with:
          path: './test/policies/valid_conditions.tf'
        env:
          GITHUB_ACTIONS: true
          
      - name: Test all expressions
        id: test-expressions
        continue-on-error: true
        uses: ./
        with:
          path: './test/policies/all_expressions.tf'
        env:
          GITHUB_ACTIONS: true
          
      - name: Test custom extractor pattern
        id: test-custom-pattern
        continue-on-error: true
        uses: ./
        with:
          path: './test/policies/valid.tf'
          extractor: 'regex'
          pattern: 'statements\s*=\s*\[(.*?)\]' # Changed extractorPattern to pattern
        env:
          GITHUB_ACTIONS: true

      - name: Test custom extractor pattern using env variable
        id: test-custom-pattern-env-var
        continue-on-error: true
        env:
          # NOTE: The 'pattern' input takes precedence over this env var if both are set.
          # This step tests if the action correctly falls back to the env var when 'pattern' input is NOT provided.
          POLICY_STATEMENTS_PATTERN: "statements\\s*=\\s*\\[\\s*((?:[^[\\]]*?(?:\"(?:[^\"\\\\]|\\\\.)*\"|'(?:[^'\\\\]|\\.)*'|\\$\\{(?:[^{}]|\\{[^{}]*\\})*\\})?)*)\\s*\\]"
          GITHUB_ACTIONS: true
        uses: ./
        with:
          path: './test/policies/valid.tf'
          extractor: 'regex'
          # No 'pattern' input here, relying on env var

      - name: Test action with fixtures
        id: test-fixtures
        continue-on-error: true
        uses: ./
        with:
          path: './src/__tests__/fixtures'
          extractor: 'regex'
          pattern: "statements\\s*=\\s*\\[\\s*((?:[^[\\]]*?(?:\"(?:[^\"\\\\]|\\\\.)*\"|'(?:[^'\\\\]|\\.)*'|\\$\\{(?:[^{}]|\\{[^{}]*\\})*\\})?)*)\\s*\\]" # Changed extractorPattern to pattern
        env:
          GITHUB_ACTIONS: true

      - name: Verify test results
        shell: bash
        env:
          # Pass outputs directly, escaped for shell usage
          TEST_VALID_OUTPUT_ESCAPED: ${{ toJson(steps.test-valid.outputs.results) }}
          TEST_INVALID_OUTPUT_ESCAPED: ${{ toJson(steps.test-invalid.outputs.results) }}
          TEST_VARS_OUTPUT_ESCAPED: ${{ toJson(steps.test-vars.outputs.results) }}
          TEST_CONDITIONS_OUTPUT_ESCAPED: ${{ toJson(steps.test-conditions.outputs.results) }}
          TEST_EXPRESSIONS_OUTPUT_ESCAPED: ${{ toJson(steps.test-expressions.outputs.results) }}
          TEST_CUSTOM_PATTERN_OUTPUT_ESCAPED: ${{ toJson(steps.test-custom-pattern.outputs.results) }}
          TEST_CUSTOM_PATTERN_ENV_VAR_OUTPUT_ESCAPED: ${{ toJson(steps.test-custom-pattern-env-var.outputs.results) }}
          TEST_FIXTURES_OUTPUT_ESCAPED: ${{ toJson(steps.test-fixtures.outputs.results) }}
          # Keep original debug vars if needed
          TEST_VALID_OUTPUT_DEBUG: ${{ steps.test-valid.outputs.results }}
          TEST_INVALID_OUTPUT_DEBUG: ${{ steps.test-invalid.outputs.results }}
          TEST_VARS_OUTPUT_DEBUG: ${{ steps.test-vars.outputs.results }}
          TEST_CONDITIONS_OUTPUT_DEBUG: ${{ steps.test-conditions.outputs.results }}
          TEST_EXPRESSIONS_OUTPUT_DEBUG: ${{ steps.test-expressions.outputs.results }}
          TEST_CUSTOM_PATTERN_OUTPUT_DEBUG: ${{ steps.test-custom-pattern.outputs.results }}
          TEST_CUSTOM_PATTERN_ENV_VAR_OUTPUT_DEBUG: ${{ steps.test-custom-pattern-env-var.outputs.results }}
          TEST_FIXTURES_OUTPUT_DEBUG: ${{ steps.test-fixtures.outputs.results }}
        run: |
          # Function to verify the JSON output and the 'isValid' flag
          verify_output() {
            local step_id="$1"           # Step ID for logging purposes
            local expected_validity="$2" # Expect 'true' or 'false'
            local escaped_var_name="TEST_${step_id//-/}_OUTPUT_ESCAPED"
            local escaped_output="${!escaped_var_name}" # Get the JSON string (already quoted/escaped by toJson)

            echo "Verifying output from step: $step_id"
            echo "Escaped output value (from env var):"
            echo "$escaped_output" # Log the escaped string

            # Safely evaluate the escaped JSON string into raw_output
            # The output from toJson is already a valid JSON string literal
            local raw_output
            # Check if escaped_output is non-empty before eval
            if [ -n "$escaped_output" ]; then
               # Use jq to parse the JSON string from the env var
               raw_output=$(jq -c . <<< "$escaped_output")
               if [ $? -ne 0 ]; then
                  echo "::error::Failed to parse JSON from env var for step $step_id"
                  echo "Escaped value was: $escaped_output"
                  return 1
               fi
            else
               raw_output="" # Set to empty if env var was empty
            fi

            echo "Raw output value (after parsing):"
            jq . <<< "$raw_output" # Pretty print JSON for debugging

            if [ -z "$raw_output" ]; then
              echo "::warning::Raw output was empty after parsing for step $step_id."
              # Check the debug env var as a fallback for inspection
              local debug_var_name="TEST_${step_id//-/}_OUTPUT_DEBUG"
              local debug_output="${!debug_var_name}"
              echo "Debug Env Var Content:"
              echo "$debug_output" | jq .
              echo "::error::No output found or parsed for step $step_id"
              return 1
            fi

            # Use the raw_output variable which contains the JSON string
            local actual_validity=$(jq -r '
              if type == "array" and length > 0 then
                # Check the first element that has an 'isValid' property
                map(select(.isValid != null)) | .[0].isValid // "null"
              else
                "invalid_json_or_empty"
              end
            ' <<< "$raw_output") # Use <<< for jq input

            echo "Extracted validity: $actual_validity" # Debugging line

            if [[ "$actual_validity" == "invalid_json_or_empty" ]]; then
              echo "::error::Output for $step_id is not a valid JSON array, is empty, or lacks 'isValid' in relevant elements."
              return 1
            elif [[ "$actual_validity" == "null" ]]; then
              echo "::error::Output for $step_id is missing the 'isValid' property in the first relevant element."
              return 1
            elif [[ "$actual_validity" != "$expected_validity" ]]; then
              echo "::error::Expected validity '$expected_validity' but got '$actual_validity' for step $step_id."
              return 1
            fi

            echo "âœ“ Output for $step_id verified successfully (isValid=$actual_validity)"
            return 0
          }

          # --- Verification ---
          errors=0

          # Call verify_output without the third argument
          verify_output "test-valid" "true" || errors=$((errors + 1))
          verify_output "test-invalid" "false" || errors=$((errors + 1))
          verify_output "test-vars" "true" || errors=$((errors + 1))
          verify_output "test-conditions" "true" || errors=$((errors + 1))
          verify_output "test-expressions" "true" || errors=$((errors + 1))
          verify_output "test-custom-pattern" "true" || errors=$((errors + 1))
          verify_output "test-custom-pattern-env-var" "true" || errors=$((errors + 1))
          verify_output "test-fixtures" "false" || errors=$((errors + 1))

          # --- Final Check ---
          if [ $errors -gt 0 ]; then
            echo "::error::$errors verification(s) failed."
            exit 1
          else
            echo "All action outputs verified successfully."
          fi

      - name: Run Jest tests # Keep Jest tests as a separate check
        run: npm test

      - name: Verify Jest test results # Keep Jest verification
        run: |
          # This step only checks if the previous Jest step succeeded
          if [[ "${{ job.status }}" == "success" ]]; then
            echo "Tests passed successfully"
            exit 0
          else
            echo "Tests failed"
            exit 1


