name: Test Policy Validation Action
on: [push, pull_request]

jobs:
  test-action:
    runs-on: ubuntu-latest
    name: Test Policy Validation
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Build action
        run: npm run build
        
      - name: Create test policies
        run: |
          mkdir -p test/policies
          # Valid policy file
          cat > test/policies/valid.tf << 'EOL'
          resource "oci_identity_policy" "valid_policy" {
            statements = [
              "Allow group Administrators to manage all-resources in tenancy",
              "Allow group Developers to use instances in compartment dev"
            ]
          }
          EOL
          
          # Invalid policy file
          cat > test/policies/invalid.tf << 'EOL'
          resource "oci_identity_policy" "invalid_policy" {
            statements = [
              "Invalid policy statement that should fail",
              "Allow BadSyntax manage"
            ]
          }
          EOL
          
          # Valid policy file with HCL variables
          cat > test/policies/valid_vars.tf << 'EOL'
          resource "oci_identity_policy" "valid_policy_vars" {
            statements = [
              "Allow group ${var.admin_group} to manage all-resources in tenancy",
              "Allow group Developers to use ${var.resource_type} in compartment ${var.dev_compartment}",
              "Allow any-user to use ${var.public_resource} in compartment ${var.public_compartment} where request.user.id = '${var.allowed_user}'"
            ]
          }
          EOL
          
          # Valid policy file with HCL variables in conditions
          cat > test/policies/valid_conditions.tf << 'EOL'
          resource "oci_identity_policy" "valid_policy_conditions" {
            statements = [
              "Allow group Developers to use instances in compartment dev where request.user.id = '${var.user_id}'",
              "Allow group Admins to manage volumes in compartment prod where request.networkSource.name = ${var.network_source}",
              "Allow any-user to use instances in compartment public where request.time BETWEEN ${var.start_time} AND ${var.end_time}"
            ]
          }
          EOL
          
          # Test file with all expression types
          cat > test/policies/all_expressions.tf << 'EOL'
          resource "oci_identity_policy" "all_expressions" {
            statements = [
              "define tenancy Acceptor as ocid1.tenancy.oc1..aaaaaaaanneylhk3ibv2dmorxqgklcloydwnror5b3fs4ag7dlrbsiwkjdea",
              "endorse group Administrators to manage drg-attachment in tenancy VCN",
              "Admit group Administrators of tenancy Requestor to manage remote-peering-to in tenancy",
              "Allow group ${var.admin_group} to manage all-resources in tenancy"
            ]
          }
          EOL
          
          # Verify files were created
          ls -la test/policies/
          cat test/policies/valid.tf
          cat test/policies/invalid.tf
          
      - name: Test valid policy
        id: test-valid
        continue-on-error: true
        uses: ./
        with:
          path: './test/policies/valid.tf'
        env:
          GITHUB_ACTIONS: true
          
      - name: Save test-valid output
        uses: actions/github-script@v6
        if: always() # Run even if the previous step failed
        with:
          script: |
            const fs = require('fs');
            // Use toJSON() to safely serialize the output as a JSON string literal
            const output = ${{ toJSON(steps.test-valid.outputs.results) }};
            core.info(`Debug output for test-valid:\n${output}`);
            fs.writeFileSync('/tmp/test-valid-output.json', output);

      - name: Test invalid policy
        id: test-invalid
        continue-on-error: true
        uses: ./
        with:
          path: './test/policies/invalid.tf'
        env:
          GITHUB_ACTIONS: true
          
      - name: Save test-invalid output
        uses: actions/github-script@v6
        if: always()
        with:
          script: |
            const fs = require('fs');
            // Use toJSON() to safely serialize the output as a JSON string literal
            const output = ${{ toJSON(steps.test-invalid.outputs.results) }};
            core.info(`Debug output for test-invalid:\n${output}`);
            fs.writeFileSync('/tmp/test-invalid-output.json', output);

      - name: Test policy with variables
        id: test-vars
        continue-on-error: true
        uses: ./
        with:
          path: './test/policies/valid_vars.tf'
        env:
          GITHUB_ACTIONS: true
          
      - name: Save test-vars output
        uses: actions/github-script@v6
        if: always()
        with:
          script: |
            const fs = require('fs');
            // Use toJSON() to safely serialize the output as a JSON string literal
            const output = ${{ toJSON(steps.test-vars.outputs.results) }};
            core.info(`Debug output for test-vars:\n${output}`);
            fs.writeFileSync('/tmp/test-vars-output.json', output);

      - name: Test conditions with variables
        id: test-conditions
        continue-on-error: true
        uses: ./
        with:
          path: './test/policies/valid_conditions.tf'
        env:
          GITHUB_ACTIONS: true
          
      - name: Save test-conditions output
        uses: actions/github-script@v6
        if: always()
        with:
          script: |
            const fs = require('fs');
            // Use toJSON() to safely serialize the output as a JSON string literal
            const output = ${{ toJSON(steps.test-conditions.outputs.results) }};
            core.info(`Debug output for test-conditions:\n${output}`);
            fs.writeFileSync('/tmp/test-conditions-output.json', output);

      - name: Test all expressions
        id: test-expressions
        continue-on-error: true
        uses: ./
        with:
          path: './test/policies/all_expressions.tf'
        env:
          GITHUB_ACTIONS: true
          
      - name: Save test-expressions output
        uses: actions/github-script@v6
        if: always()
        with:
          script: |
            const fs = require('fs');
            // Use toJSON() to safely serialize the output as a JSON string literal
            const output = ${{ toJSON(steps.test-expressions.outputs.results) }};
            core.info(`Debug output for test-expressions:\n${output}`);
            fs.writeFileSync('/tmp/test-expressions-output.json', output);

      - name: Test custom extractor pattern
        id: test-custom-pattern
        continue-on-error: true
        uses: ./
        with:
          path: './test/policies/valid.tf'
          extractor: 'regex'
          pattern: 'statements\s*=\s*\[(.*?)\]' # Changed extractorPattern to pattern
        env:
          GITHUB_ACTIONS: true

      - name: Save test-custom-pattern output
        uses: actions/github-script@v6
        if: always()
        with:
          script: |
            const fs = require('fs');
            // Use toJSON() to safely serialize the output as a JSON string literal
            const output = ${{ toJSON(steps.test-custom-pattern.outputs.results) }};
            core.info(`Debug output for test-custom-pattern:\n${output}`);
            fs.writeFileSync('/tmp/test-custom-pattern-output.json', output);

      - name: Test custom extractor pattern using env variable
        id: test-custom-pattern-env-var
        continue-on-error: true
        env:
          # NOTE: The 'pattern' input takes precedence over this env var if both are set.
          # This step tests if the action correctly falls back to the env var when 'pattern' input is NOT provided.
          POLICY_STATEMENTS_PATTERN: "statements\\s*=\\s*\\[\\s*((?:[^[\\]]*?(?:\"(?:[^\"\\\\]|\\\\.)*\"|'(?:[^'\\\\]|\\.)*'|\\$\\{(?:[^{}]|\\{[^{}]*\\})*\\})?)*)\\s*\\]"
          GITHUB_ACTIONS: true
        uses: ./
        with:
          path: './test/policies/valid.tf'
          extractor: 'regex'
          # No 'pattern' input here, relying on env var

      - name: Save test-custom-pattern-env-var output
        uses: actions/github-script@v6
        if: always()
        with:
          script: |
            const fs = require('fs');
            // Use toJSON() to safely serialize the output as a JSON string literal
            const output = ${{ toJSON(steps.test-custom-pattern-env-var.outputs.results) }};
            core.info(`Debug output for test-custom-pattern-env-var:\n${output}`);
            fs.writeFileSync('/tmp/test-custom-pattern-env-var-output.json', output);

      - name: Test action with fixtures
        id: test-fixtures
        continue-on-error: true
        uses: ./
        with:
          path: './src/__tests__/fixtures'
          extractor: 'regex'
          pattern: "statements\\s*=\\s*\\[\\s*((?:[^[\\]]*?(?:\"(?:[^\"\\\\]|\\\\.)*\"|'(?:[^'\\\\]|\\.)*'|\\$\\{(?:[^{}]|\\{[^{}]*\\})*\\})?)*)\\s*\\]" # Changed extractorPattern to pattern
        env:
          GITHUB_ACTIONS: true

      - name: Save test-fixtures output
        uses: actions/github-script@v6
        if: always()
        with:
          script: |
            const fs = require('fs');
            // Use toJSON() to safely serialize the output as a JSON string literal
            const output = ${{ toJSON(steps.test-fixtures.outputs.results) }};
            core.info(`Debug output for test-fixtures:\n${output}`);
            fs.writeFileSync('/tmp/test-fixtures-output.json', output);

      - name: Verify test results
        if: always() # Ensure verification runs even if tests failed
        shell: bash
        # No env vars needed here for outputs
        run: |
          # Function to verify the JSON output and the 'isValid' flag
          verify_output() {
            local step_id="$1"           # Step ID for logging purposes
            local expected_validity="$2" # Expect 'true' or 'false'
            local filename="/tmp/${step_id}-output.json"

            echo "Verifying output from step: $step_id"

            if [ ! -f "$filename" ]; then
              echo "::error::Output file $filename not found for step $step_id."
              return 1
            fi

            # Read the raw output from the file
            local raw_output
            raw_output=$(cat "$filename")

            echo "Raw output value (from file $filename):"
            # Log raw output carefully
            printf '%s\n' "$raw_output" | jq . # Attempt to pretty print if it's JSON

            # Check if the raw_output is empty OR if it's the literal unevaluated expression string
            # Also check if it's just an empty JSON string "" which toJSON might produce for empty output
            if [ -z "$raw_output" ] || [[ "$raw_output" == \$\{\{*\}\} ]] || [[ "$raw_output" == '""' ]]; then
              echo "::warning::Output file $filename was empty, contained unevaluated expression, or was empty JSON string for step $step_id."
              # If the step producing the output failed or was skipped, this might be expected.
              # Check if the corresponding step actually failed/was skipped.
              # Note: This check is complex to implement reliably here. Let's focus on jq parsing first.
              # For now, treat empty/invalid output as an error in verification.
              echo "::error::No valid output JSON found for step $step_id"
              return 1
            fi

            # Use the raw_output variable which contains the JSON string
            # Use process substitution with printf for safer input to jq
            local actual_validity
            local jq_output
            # Updated jq filter:
            # - Check if it's a non-empty array first.
            # - Select elements where isValid is false. If count > 0, output "false".
            # - Select elements where isValid is true. If count == total length, output "true".
            # - Otherwise (mixed, missing isValid, etc.), output "null".
            jq_output=$(jq -r '
              if type == "array" and length > 0 then
                # Check if any element explicitly has isValid == false
                if (map(select(.isValid == false)) | length) > 0 then
                  "false"
                # Check if ALL elements explicitly have isValid == true
                elif (map(select(.isValid == true)) | length) == length then
                  "true"
                else # Handles arrays with missing isValid or other inconsistencies
                  "null"
                end
              else # Handles non-arrays, empty arrays
                "null"
              end
            ' <(printf '%s' "$raw_output") 2>/dev/null) # Redirect jq errors to /dev/null
            local jq_exit_code=$? # Capture exit code immediately

            # Check jq exit status
            if [ $jq_exit_code -ne 0 ]; then
               echo "::error::jq failed to parse JSON content from $filename for step $step_id."
               printf 'Problematic file content:\n%s\n' "$raw_output"
               actual_validity="invalid_json_or_empty" # Force failure path
            else
               actual_validity="$jq_output" # Assign the valid output ("true", "false", or "null")
            fi

            echo "Extracted validity: $actual_validity" # Debugging line

            if [[ "$actual_validity" == "invalid_json_or_empty" ]]; then
              echo "::error::Output for $step_id could not be parsed by jq."
              printf 'Problematic JSON input:\n%s\n' "$raw_output" # Log the problematic input
              return 1
            elif [[ "$actual_validity" == "null" ]]; then
              echo "::error::Output for $step_id is missing the 'isValid' property in the first element, or the structure is wrong."
              printf 'Problematic JSON input:\n%s\n' "$raw_output" # Log the problematic input
              return 1
            elif [[ "$actual_validity" != "$expected_validity" ]]; then
              echo "::error::Expected validity '$expected_validity' but got '$actual_validity' for step $step_id."
              return 1
            fi

            echo "✓ Output for $step_id verified successfully (isValid=$actual_validity)"
            return 0
          }

          # --- Verification ---
          errors=0

          # Call verify_output and check exit status $? separately
          verify_output "test-valid" "true"
          if [ $? -ne 0 ]; then errors=$((errors + 1)); fi

          verify_output "test-invalid" "false"
          if [ $? -ne 0 ]; then errors=$((errors + 1)); fi

          verify_output "test-vars" "true"
          if [ $? -ne 0 ]; then errors=$((errors + 1)); fi

          verify_output "test-conditions" "true"
          if [ $? -ne 0 ]; then errors=$((errors + 1)); fi

          verify_output "test-expressions" "true"
          if [ $? -ne 0 ]; then errors=$((errors + 1)); fi

          verify_output "test-custom-pattern" "true"
          if [ $? -ne 0 ]; then errors=$((errors + 1)); fi

          verify_output "test-custom-pattern-env-var" "true"
          if [ $? -ne 0 ]; then errors=$((errors + 1)); fi

          verify_output "test-fixtures" "false"
          if [ $? -ne 0 ]; then errors=$((errors + 1)); fi

          # --- Final Check ---
          if [ $errors -gt 0 ]; then
            echo "::error::$errors verification(s) failed."
            exit 1
          else
            echo "All action outputs verified successfully."
          fi

      - name: Run Jest tests # Keep Jest tests as a separate check
        run: npm test -- --testPathIgnorePatterns=cli.test.ts

      - name: Verify Jest test results # Keep Jest verification
        run: |
          # This step only checks if the previous Jest step succeeded
          if [[ "${{ job.status }}" == "success" ]]; then
            echo "Tests passed successfully"
            exit 0
          else
            echo "Tests failed"
            exit 1


